---
title: "Estudio empírico del orden de la multiplicación de matrices"
author: "Taller 1 Matemáticas III GINF 19-20."
date: 
output:
  html_document:
    fig_caption: yes
    toc: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#  Generación de la muestra

La muestra se ha obtenido con el código siguiente que no se ejecuta. Por reproductividad se ha guardado en el objeto de R `dades1000`

```
# ya no va este paquete 
library(parallel)
# Calculo en número de cores del sistema
no_cores <- detectCores() - 1
no_cores 
# Inicializo el cluster
cl <- makeCluster(no_cores)
cl
#lanzo la muestra
data1000=parLapply(cl,seq(10,5000,100),fun=function(n){
random_matrix_n=function(n){
M1=matrix(runif(n^2),ncol=n)
M2=matrix(runif(n^2),ncol=n)
system.time(M1%*%M2, gcFirst = TRUE)}
c(n,sum(replicate(1,random_matrix_n(n),simplify="array")))
}
)
stopCluster(cl)
#salvamos el objeto en el working directory actual
save(data1000,file"data1000.Robj")
```


# Carga de datos

Cargamos los datos, los transformamos en un `data frame` de dos variables `n` y `seconds`

```{r}
#cargamos el objeto del working directory actual
load("data1000.Robj")
class(data1000)
#no muestro la extructura pues es muy larga
#str(data1000)
head(data1000)
data=as.data.frame(matrix(unlist(data1000),ncol=2,byrow=TRUE))
head(data)
#ponemos nombres
names(data)=c("n","seconds")
#eliminamos las filas con seconds=0
data=data[data$seconds!=0,]
head(data)
```

# Estudio del ajuste de tres modelos de curvas de orden

Vamos a estudiar si los modelos de orden del algoritmo de multiplicación de matrices se ajustan a un modelo lineal a uno exponencial o a uno potencial. Recordemos que sabemos que la multiplicación de matrices cuadradas de orden es  $O(n^3)$.

Os pongo sólo el código simple, vosotros ampliad-lo y poned nombres a los gráficos

## Regresión lineal

Pon el modelo

```{r}
lm_x_y=lm(seconds~n,data=data)
summary(lm_x_y)
plot(data,main="Pon tu main")
abline(lm_x_y,col="red")
```

## Regresión exponencial (semilog)

Pon el modelo

```{r}
lm_x_logy=lm(log10(seconds)~n,data=data)
summary(lm_x_logy)
plot(data,main="Pon tu main",log="y")
abline(lm_x_logy,col="red")
```

## Regresión potencial (loglog)


```{r}
lm_x_logy=lm(log10(seconds)~n,data=data)
summary(lm_x_logy)
plot(data,main="Pon tu main",log="y")
abline(lm_x_logy,col="red")
```

Pon el modelo

```{r}
lm_logx_logy=lm(log10(seconds)~log10(n),data=data)
summary(lm_logx_logy)
plot(data,main="Pon tu main",log="xy")
abline(lm_logx_logy,col="red")
```

# Estudio del ajuste de tres modelos de curvas de orden



## Selección del mejor modelo

En principio el modelo con mejor $R^2$ es el log-log que equivale a  una curva potencial $$second\approx \beta\cdot n^{\alpha}$$.

Como hemos visto en el manual (tema2 MOOC), si 
$log_{10}(seconds)= a \cdot log_{10}(n)+ b$ Entonces $\beta= 10^b$ y $\alpha=a$.

Así que 

```{r}
b=lm_logx_logy$coefficients[1]
a=lm_logx_logy$coefficients[2]
b
a
beta=10^b
beta
alpha=a
alpha
```

# Estudio del ajuste de tres modelos de curvas de orden


Así que el modelo potencial es $$secons\approx `r beta` \cdot n^{`r \alpha}$$.

Ahora podemos hacer el dibujo de la curva y los datos en las unidades originales


```{r}
plot(data,main="Simulación del orden de complejidad\n de la multiplicación de matrices")
curve(beta*x^alpha,add=TRUE,col="blue")
```



# Un poco más... 

Aunque muy utilizado el recurso la estimación de los coeficientes de funciones no lineales mediante su transformación a lineales no es perfecto. Al hacerlo la transformación lineal que  se minimiza no es el error cuadrático medio sino el error cuadrático medio de la transformación, por ejemplo, los logaritmos de la variable. Por supuesto que hay otros métodos numéricos para encontrar estos coeficientes de  forma más precisa, más abajo veremos una manera.

Entended que esto se ha hecho así pues no conocíamos (o sí nos lo habían contado) el orden del algoritmo, así que había que apostar sobre si era lineal, polinomial o exponencial. Además  una vez decidido el modelo habría que averiguar sus parámetros.

En nuestro caso hemos elegido el modelo potencial. Ademas que orden $n^3$ incluye a todos los ordenes de la forma $a_3\cdot n^3+a_2\cdot n^2+a_1 \cdot n+ a_0$.

Así que vamos a hacer al revés vamos a probar si los datos se ajustan bien a un modelo de un polinomio cúbico. El siguiente código nos responde esta cuestión.

```{r}
#Notemos que para que calcule n^3 hay que poner en el modelo I(n^3) ya que
#esta variable no figura en data. Sí es verdad con los log si la calcula, pero otras #operaciones no.
pol3= lm(seconds~1+n+I(n^2)+I(n^3),data=data)
summary(pol3)
ai=coefficients(pol3)
ai
plot(data,main="Aproximación del orden por polinomio cúbico")
curve(ai[1]+ai[2]*x+ai[3]*x^2+ai[4]*x^3,add=TRUE,col="green")
```

Si solo tenemos en cuenta el coeficiente de determinación obtenemos la mejor aproximación $R^2=`r summary(pol3)$adj.r.squared`$. Y creo que acabamos; el  profesor que os explico órdenes de algoritmos tenía razón:-) ¿o no?.

Pues no esta claro la verdad y esto nos invita a introducir  una práctica de regresión múltiple de la que adelanto el código



```{r}
step(lm(seconds~1+n+I(n^2)+I(n^3),data=data))
```


# Trabajo futuro

¿Es la muestra que hemos tomado demasiado pequeña? ¿necesitamos valores del orden de las matrices superiores? El desenlace próximamente y en esta misma asignatura. 



















